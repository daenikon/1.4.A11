# Understand How It works
Before customizing my Btrfs setup, I will familiarize myself with its workings by reviewing the [official documentation](https://btrfs.readthedocs.io/en/latest/index.html),
exploring user experiences on reddit ([r/btrfs](https://www.reddit.com/r/btrfs/), [r/linux](https://www.reddit.com/r/linux/) and [r/archlinux](https://www.reddit.com/r/archlinux/)), and consulting both the [Arch Wiki](https://wiki.archlinux.org/title/Btrfs) and [Gentoo Wiki](https://wiki.gentoo.org/wiki/Btrfs) for their insights.

## Btrfs' docs
**copy-on-write**
: *Also known as COW. The method that btrfs uses for modifying data. Instead of directly overwriting data in place,
  btrfs takes a copy of the data, alters it, and then writes the modified data back to a different (free) location
  on the disk. It then updates the metadata to reflect the new location of the data. In order to update the metadata,
  the affected metadata blocks are also treated in the same way. In COW filesystems, files tend to fragment as they
  are modified. Copy-on-write is also used in the implementation of snapshots and reflink copies. A copy-on-write
  filesystem is, in theory, always consistent, provided the underlying hardware supports barriers.*[^1]
  
**The way I understood it**:
  btrfs functions in a snapshot-like way - meaning that when a block of data is modified, the changes are written to
  a new block, which leaves the original block untouched. The association that comes to mind is with version
  control's commit, but the difference would be that version control makes a point to retain the whole history of
  changes, while CoW's not. CoW's mechanism allows for quick snapshot creation, as a snapshot in essense just
  refers to existing blocks without needing to duplicate any of them.

**checksum**
: *A checksum is a small-sized block of data derived from another block of digital data for the purpose of detecting
  errors that may have been introduced during its transmission or storage.*[^2]

**The way I understood it**:
  Checksum is essentially a unique digital signature for a piece of data. It's generated by applying a specific
  mathematical algorithm to the data, resulting in a fixed-size value. Changing even a single byte in the data
  leads to a dramatically different checksum. Thus, by comparing checksums, one can determine whether two sets
  of data are identical without comparing the data byte by byte.

**In context of btrfs**:
*Data and metadata are checksummed by default, the checksum is calculated before write and verified after reading the blocks from devices.*[^3]

**reflink**
: *Reflink is a type of shallow copy of file data that shares the blocks but otherwise the files are independent
  and any change to the file will not affect the other. This builds on the underlying COW mechanism. A reflink
  will effectively create only a separate metadata pointing to the shared blocks which is typically much faster
  than a deep copy of all blocks.*[^4]

**scrub**
: *Scrub is a pass over all filesystem data and metadata and verifying the checksums. If a valid copy is
  available (replicated block group profiles) then the damaged one is repaired. All copies of the replicated
  profiles are validated.*[^5]

**subvolume**
: *A BTRFS subvolume is a part of filesystem with its own independent file/directory hierarchy and inode
  number namespace. Subvolumes can share file extents. A snapshot is also subvolume, but with a given initial
  content of the original subvolume.*[^6] 

* I have NVMe disk, therefore there's no reason to use defragmentation or RAID for me. Thus, I guess the main disadvantage of using btrfs is:
  >*If data is damaged in some way (cosmic rays, bad disk sector, accident with dd to the disk), then the snapshot and the original will both be damaged.*[^6]
(but for NVMe the chances are still low)

## Reddit
### General Consensus
Seems like BTRFS has a generally bad reputation without much evidence backing it up.
Main points for it are:
* RAID 5/6
* Quotas
* Swapfile

1. Needless, to say I'm not going use RAID 5/6 for two reasons - I don't need it and [btrfs's status page](https://btrfs.readthedocs.io/en/latest/Status.html) clearly states that it is **unstable**. Nevertheless, I've read so many posts about RAID 5/6 - how it corrupts data, how unstable it is and how it ruined btrfs for those people forever. It's baffling to see people using it when developers themselves advise against its use.
2. Pretty much the same as RAID 5/6, since at the time they were barely supported. With time they got better support, while RAID 5/6 didn't.
3. Swapfile, in general, was always a topic of debate. Some time ago I've read, that certain version broke btrfs' swapfile, which crashed the system or something like that.

### Tips&Tricks
* Based on that if the snapshot of a certain subvolume is taken, it will not include nested subvolumes in it. People recommend to create separate subvolumes for `/var/log`, `/var/cache` and `/home` directories

## Wikis
As far as I've found out - OpenSUSE and Fedora use btrfs as their default filesystem, but their docs/wiki about it are either outdated and archived or just non-existent, which is a bummer.

### Arch Wiki
* [link](https://wiki.archlinux.org/title/Btrfs)
* According to their [Known Issues](https://wiki.archlinux.org/title/Btrfs#Known_issues) section, `btrfs-check` tool is under heavy development and it is NOT advised to use it.
* In the [Compression](https://wiki.archlinux.org/title/Btrfs#Compression) section is written that using `compress-force=alg[:level]` mount option over regular `compress=alg[:level]` shows a significant improvement of about 10% disk compression and slightly more CPU usage, which is a good trade-off.
* [compsize](https://wiki.archlinux.org/title/Btrfs#View_compression_types_and_ratios) tool seems worth checking out
* [Snapper](https://wiki.archlinux.org/title/Snapper#Suggested_filesystem_layout) has a suggested filesystem layout
* In the Trouble

# Usage
## Scrub
*The user is supposed to run it manually or via a periodic system service. The recommended period is a month but could be less.*[^5]

## Subvolumes
* [system root layouts](https://btrfs.readthedocs.io/en/latest/Subvolumes.html#case-study-system-root-layouts)
* [mount options](https://btrfs.readthedocs.io/en/latest/Subvolumes.html#mount-options)

I guess that besides making a separate subvolume `/var/log` and `/var/cache`, it would be also beneficial to set
`nodatacow` to them, since logs are constantly changing. 
  


# References
[^1]: [Btrfs's Glossary](https://btrfs.readthedocs.io/en/latest/Glossary.html)
[^2]: [Checksum Wiki](https://en.wikipedia.org/wiki/Checksum)
[^3]: [Checksumming](https://btrfs.readthedocs.io/en/latest/Checksumming.html)
[^4]: [Reflink](https://btrfs.readthedocs.io/en/latest/Reflink.html)
[^5]: [Scrub](https://btrfs.readthedocs.io/en/latest/Scrub.html)
[^6]: [Subvolumes](https://btrfs.readthedocs.io/en/latest/Subvolumes.html)



# Random
do not use defragmentation:
Should I defragment my btrfs root fs? I've enabled zstd compression mount options late in the installation and have around 7GiB uncompressed, I don't have any snapshots or reflinks created, but I have NVMe disk and heard that defragmentation may wear out the drive very fast

Forza 23:17:24
Guest84: not needed. they will get compressed as you upgrade the system and install new stuff. And if they don't it means those particular files arent used that much.
unless you have a tiny disk and need that extra disk space.


also i guess i would backup gentoo cache folder

daily fstrim at 6am? you can even say "fstrim -m 1048576" to discard only above 1MB.
which is very likely adequate anyway.
F
Forza 23:33:28
daily or maybe weekly is enough for most lightly used systems


disable discard=async and move to fstrim timer
